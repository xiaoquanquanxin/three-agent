# Three-Agent 技术问题解答

## 技术栈
- **后端**: TypeScript + Node.js, LangGraph, MCP, Agent Skill
- **前端**: React, Three.js

---

## 1. Supervisor Agent 模式下的 Checkpoint 存储

### Checkpoint 存储机制

在 LangGraph 的 Supervisor Agent 模式下，checkpoint 用于保存对话状态，支持暂停、恢复和时间旅行功能。

**存储方式：**
- **MemorySaver**: 内存存储（开发环境）
- **SqliteSaver**: SQLite 数据库（生产环境）
- **PostgresSaver**: PostgreSQL 数据库（分布式环境）

```typescript
import { MemorySaver } from "@langchain/langgraph";

const checkpointer = new MemorySaver();
const app = graph.compile({ checkpointer });
```

### State 结构设计

Supervisor Agent 的 state 通常包含以下字段：

```typescript
interface SupervisorState {
  // 消息历史
  messages: BaseMessage[];

  // 当前激活的 agent
  next: string;

  // 任务分配信息
  task?: string;

  // 子 agent 的执行结果
  agentResults?: Record<string, any>;

  // 用户输入
  userInput?: string;

  // 最终输出
  finalOutput?: string;
}
```

**关键点：**
- `messages` 保存完整的对话历史
- `next` 指示下一个要执行的节点（supervisor 或具体的 worker agent）
- 使用 `Annotation` 定义 state 的归并策略（如 messages 使用 addMessages）

---

## 2. 如何组织 Agent Skill（基于 Claude Code）

### 什么是 Skill？

**Skill** 是一个 Markdown 文件，用于教 Claude 如何执行特定任务。关键特点：
- **自动触发**：Claude 根据语义匹配自动选择使用
- **知识扩展**：为 Claude 提供专业领域知识
- **可共享**：可在个人、项目或组织级别共享

### 项目中的 Skill 目录结构

```
three-agent/
├── .claude/
│   └── skills/
│       ├── supervisor-manager/
│       │   ├── SKILL.md           # Supervisor agent 管理技能
│       │   └── examples.md
│       ├── langgraph-workflow/
│       │   ├── SKILL.md           # LangGraph 工作流设计
│       │   ├── patterns.md        # 常见模式
│       │   └── scripts/
│       │       └── validate_graph.py
│       ├── mcp-integration/
│       │   ├── SKILL.md           # MCP 工具集成
│       │   └── mcp-reference.md
│       └── threejs-agent/
│           ├── SKILL.md           # Three.js 相关任务
│           └── scene-templates/
```

### Skill 文件格式（SKILL.md）

```yaml
---
name: supervisor-manager
description: Manage LangGraph supervisor agents, design state transitions, and handle agent coordination. Use when working with supervisor patterns, agent routing, or multi-agent workflows.
allowed-tools: Read, Write, Edit, Bash
model: claude-opus-4-5-20251101
---

# Supervisor Agent Manager

## Instructions

当处理 Supervisor Agent 时：

1. **State 设计**
   - 定义清晰的消息流
   - 使用 Annotation 管理状态归并
   - 包含 `next` 字段用于路由

2. **Agent 路由**
   - Supervisor 决定下一个执行的 worker
   - 使用条件边（conditional edges）
   - 实现 fallback 机制

3. **Checkpoint 配置**
   - 开发环境使用 MemorySaver
   - 生产环境使用持久化存储
   - 配置 thread_id 管理会话

## Examples

### 创建 Supervisor Node

```typescript
import { ChatAnthropic } from "@langchain/anthropic";

const supervisorNode = async (state: State) => {
  const model = new ChatAnthropic({
    modelName: "claude-opus-4-5-20251101",
  });

  const prompt = `You are a supervisor managing these workers: ${workers.join(", ")}.
  Given the user request, decide which worker should act next.`;

  const response = await model.invoke([
    { role: "system", content: prompt },
    ...state.messages,
  ]);

  return {
    messages: [response],
    next: extractNextWorker(response.content),
  };
};
```

### State Annotation

```typescript
import { Annotation } from "@langchain/langgraph";
import { BaseMessage } from "@langchain/core/messages";

const StateAnnotation = Annotation.Root({
  messages: Annotation<BaseMessage[]>({
    reducer: (x, y) => x.concat(y),
  }),
  next: Annotation<string>({
    reducer: (x, y) => y ?? x,
  }),
});
```

## Reference Files

- 详细的状态管理模式：[patterns.md](patterns.md)
- Checkpoint 配置指南：[checkpoint-guide.md](checkpoint-guide.md)
```

### 另一个 Skill 示例：MCP Integration

```yaml
---
name: mcp-integration
description: Integrate Model Context Protocol (MCP) servers and tools with LangGraph agents. Use when adding MCP tools, configuring MCP servers, or debugging MCP connections.
allowed-tools: Read, Write, Edit, Bash
---

# MCP Integration Skill

## Instructions

### 添加 MCP Server

1. **安装 MCP SDK**
   ```bash
   npm install @modelcontextprotocol/sdk
   ```

2. **创建 MCP 客户端**
   ```typescript
   import { Client } from "@modelcontextprotocol/sdk/client/index.js";
   import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";

   const transport = new StdioClientTransport({
     command: "npx",
     args: ["-y", "@modelcontextprotocol/server-filesystem", "/path"],
   });

   const client = new Client({
     name: "my-agent",
     version: "1.0.0",
   }, {
     capabilities: {},
   });

   await client.connect(transport);
   ```

3. **将 MCP 工具转换为 LangChain 工具**
   ```typescript
   const mcpTools = await client.listTools();

   const langchainTools = mcpTools.tools.map(tool => ({
     name: tool.name,
     description: tool.description,
     call: async (input: any) => {
       const result = await client.callTool({
         name: tool.name,
         arguments: input,
       });
       return result.content;
     },
   }));
   ```

## Common MCP Servers

- **filesystem**: 文件系统访问
- **git**: Git 仓库操作
- **postgres**: 数据库查询
- **puppeteer**: 浏览器自动化

## Troubleshooting

运行诊断脚本：
```bash
python scripts/diagnose_mcp.py
```

详细参考：[mcp-reference.md](mcp-reference.md)
```

### 最佳实践

#### 1. 保持 SKILL.md 精简（<500 行）
```
supervisor-manager/
├── SKILL.md              # 核心指令和快速开始
├── patterns.md           # 详细的设计模式
├── checkpoint-guide.md   # Checkpoint 配置详解
└── examples/
    ├── basic-supervisor.ts
    └── advanced-routing.ts
```

#### 2. 使用渐进式披露
- SKILL.md 中包含必要信息和链接
- 详细文档放在支持文件中
- Claude 按需读取支持文件

#### 3. 编写清晰的触发描述

**不好的描述：**
```yaml
description: Helps with agents
```

**好的描述：**
```yaml
description: Manage LangGraph supervisor agents, design state transitions, and handle agent coordination. Use when working with supervisor patterns, agent routing, multi-agent workflows, or when the user mentions "supervisor", "agent routing", "state management".
```

#### 4. 使用 Scripts 目录

将实用工具放在 `scripts/` 中，让 Claude 执行而非读取：

```markdown
## 验证工作流

运行验证脚本：
```bash
python scripts/validate_graph.py workflow.json
```
```

这样只有输出计入上下文，代码不占用 token。

#### 5. 工具权限控制

使用 `allowed-tools` 限制工具访问：

```yaml
---
name: readonly-inspector
description: Inspect code without making changes
allowed-tools: Read, Grep, Glob
---
```

### Skill 在项目中的应用场景

| Skill 名称 | 用途 | 触发关键词 |
|-----------|------|-----------|
| `supervisor-manager` | Supervisor agent 开发 | supervisor, routing, coordination |
| `langgraph-workflow` | 工作流设计和优化 | workflow, graph, state machine |
| `mcp-integration` | MCP 工具集成 | mcp, model context protocol, tools |
| `threejs-agent` | Three.js 场景管理 | threejs, 3d, scene, mesh |
| `stream-handler` | 流式输出实现 | stream, sse, real-time |

---

## 3. Agent MCP 接口的 Stream 输出

### 可以实现 Stream 输出

后端接口接入 Agent MCP **可以**输出 stream 数据。LangGraph 原生支持流式输出。

### 实现方式（使用 SSE）

```typescript
import express from 'express';
import { CompiledStateGraph } from "@langchain/langgraph";

const app = express();

app.post('/agent/stream', async (req, res) => {
  // 设置 SSE headers
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');

  const { input, threadId } = req.body;

  const config = {
    configurable: { thread_id: threadId },
    streamMode: "values" as const, // 或 "updates", "messages"
  };

  try {
    // 使用 stream 方法
    const stream = await graph.stream(input, config);

    for await (const chunk of stream) {
      // 发送 SSE 数据
      res.write(`data: ${JSON.stringify(chunk)}\n\n`);
    }

    res.write('data: [DONE]\n\n');
    res.end();
  } catch (error) {
    res.write(`data: ${JSON.stringify({ error: error.message })}\n\n`);
    res.end();
  }
});
```

### 前端接收示例（React + Three.js）

```typescript
import { useState } from 'react';

const useAgentStream = () => {
  const [response, setResponse] = useState('');
  const [isStreaming, setIsStreaming] = useState(false);

  const streamAgentResponse = async (input: string) => {
    setIsStreaming(true);
    setResponse('');

    const res = await fetch('/agent/stream', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ input, threadId: 'thread-1' }),
    });

    const reader = res.body?.getReader();
    const decoder = new TextDecoder();

    while (true) {
      const { done, value } = await reader!.read();
      if (done) break;

      const chunk = decoder.decode(value);
      const lines = chunk.split('\n');

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6);
          if (data === '[DONE]') {
            setIsStreaming(false);
            return;
          }

          const parsed = JSON.parse(data);
          setResponse(prev => prev + JSON.stringify(parsed));
        }
      }
    }
  };

  return { response, isStreaming, streamAgentResponse };
};
```

### Stream Mode 选项

| Mode | 输出内容 | 使用场景 |
|------|---------|---------|
| `values` | 每个节点执行后的完整 state | 需要完整状态快照 |
| `updates` | State 的增量更新 | 优化带宽，只需变更 |
| `messages` | 只输出新消息 | 聊天应用 |

### 与 MCP 结合的流式输出

```typescript
import { Client } from "@modelcontextprotocol/sdk/client/index.js";

// 在 LangGraph 节点中使用 MCP 工具
const mcpNode = async (state: State) => {
  const result = await mcpClient.callTool({
    name: "search_database",
    arguments: { query: state.userInput },
  });

  return {
    messages: [...state.messages, {
      role: "assistant",
      content: result.content[0].text,
    }],
  };
};

// 流式输出整个工作流
for await (const chunk of graph.stream(input, config)) {
  console.log(chunk); // 包含 MCP 工具的结果
}
```

### 使用 astream_events（更细粒度控制）

```typescript
import { graph } from "./workflow";

app.post('/agent/stream-events', async (req, res) => {
  res.setHeader('Content-Type', 'text/event-stream');

  const stream = graph.streamEvents(req.body.input, {
    version: "v2",
    configurable: { thread_id: req.body.threadId },
  });

  for await (const event of stream) {
    if (event.event === "on_chat_model_stream") {
      // 流式输出模型的 token
      res.write(`data: ${JSON.stringify({
        type: 'token',
        content: event.data.chunk.content,
      })}\n\n`);
    } else if (event.event === "on_tool_start") {
      // 工具开始调用
      res.write(`data: ${JSON.stringify({
        type: 'tool_start',
        tool: event.name,
      })}\n\n`);
    }
  }

  res.end();
});
```

---

## 总结

### 核心要点

1. **Checkpoint**:
   - 使用合适的 Saver（MemorySaver/SqliteSaver/PostgresSaver）
   - State 包含 messages、next、任务信息等
   - 通过 thread_id 管理会话

2. **Agent Skill（Claude Code）**:
   - 使用 `.claude/skills/` 目录组织
   - 每个 Skill 一个文件夹，包含 `SKILL.md`
   - 保持精简，使用支持文件和 scripts
   - 编写清晰的描述让 Claude 自动触发
   - 使用 `allowed-tools` 控制权限

3. **Stream 输出**:
   - LangGraph 原生支持 `.stream()` 和 `.streamEvents()`
   - 使用 SSE 或 WebSocket 传输
   - 三种模式：values（完整）、updates（增量）、messages（消息）
   - MCP 工具结果也可以流式输出

### 推荐的项目结构

```
three-agent/
├── .claude/
│   └── skills/               # Claude Code Skills
│       ├── supervisor-manager/
│       ├── langgraph-workflow/
│       ├── mcp-integration/
│       └── threejs-agent/
├── src/
│   ├── agents/               # LangGraph agents
│   │   ├── supervisor.ts
│   │   └── workers/
│   ├── mcp/                  # MCP 客户端和工具
│   ├── graph/                # 工作流定义
│   └── api/                  # Express 路由（含 stream）
└── frontend/
    └── components/           # React + Three.js 组件
```

这样的架构结合了 LangGraph 的强大工作流、MCP 的工具生态和 Claude Code Skills 的知识扩展能力。
