# 讨论记录 #7 - 最终架构确认和开发启动

> 时间：2026-01-12
> 主题：最终架构确认、环境配置、任务主线规划

---

## 一、环境配置确认 ✅

### 1. 数据库方案
**最终选择：SQLite**

**原因：**
- 用户本地有 MySQL 但不熟悉配置
- SQLite 零配置，只需 npm 安装 `better-sqlite3`
- 文件数据库，非常适合本地开发
- 用户有 Navicat Premium Lite 可以查看 SQLite 数据库

**如何查看数据库：**
- 使用 Navicat Premium Lite
  1. 新建连接 → 选择 SQLite
  2. 选择 `database.db` 文件
  3. 可视化查看所有表和数据

### 2. LLM API 配置
**从 .env 文件读取：**
```env
# 阿里云通义千问 API
API_KEY=sk-28ddaecd764943b3939471e7e0954e69
BASE_URL=https://dashscope.aliyuncs.com/compatible-mode/v1
MODEL_NAME=qwen-max

# LangChain 需要这个环境变量
OPENAI_API_KEY=sk-28ddaecd764943b3939471e7e0954e69

# 服务器配置
PORT=8888

# 数据库配置
DATABASE_URL="file:./dev.db"
```

### 3. 项目结构
```
three-agent/
├── backend/           # 后端项目（Node.js + LangGraph）
├── frontend/          # 前端项目（React + Three.js）
├── doc/              # 文档目录
├── demo/             # 示例代码（参考用）
├── .env              # 环境变量
└── README.md
```

**前后端分离：**
- 后端端口：随意（建议 3001）
- 前端端口：随意（Vite 默认 5173）

---

## 二、从 demo/supervisor.ts 学到的架构

### demo 的核心机制

**文件结构：**
- `demo/supervisor.ts` - 主入口，创建 workflow
- `demo/agents/supervisor.ts` - Supervisor Agent（意图识别和路由）
- `demo/agents/image_generation.ts` - 子 Agent 示例
- `demo/agent_types/state.ts` - State 定义

**关键代码模式：**

#### 1. Supervisor Agent 使用 Command 进行路由
```typescript
// demo/agents/supervisor.ts
export function createSupervisorAgent() {
  return async function supervisorAgent(state: AgentState): Promise<Command<NextAgent>> {
    // LLM 判断下一个任务
    const nextAgent = determineNextAgent(state);

    return new Command({
      goto: nextAgent,  // 路由到下一个 Agent
      update: {
        next_agent: nextAgent,
        current_task: nextAgent,
        messages: [...state.messages, ...]
      }
    });
  };
}
```

#### 2. 子 Agent 完成后回到 Supervisor
```typescript
// demo/agents/image_generation.ts
export function createImageGenerationAgent() {
  return async function imageGenerationAgent(state: AgentState): Promise<Command<"supervisor">> {
    // 执行任务...

    return new Command({
      goto: "supervisor",  // 回到 Supervisor
      update: {
        processed_image_url: "...",
        messages: [...]
      }
    });
  };
}
```

#### 3. Workflow 构建
```typescript
// demo/supervisor.ts
function createWorkflow() {
  const builder = new StateGraph<AgentState>({
    channels: {
      messages: { reducer: (x, y) => x.concat(y) },
      next_agent: null,
      current_task: null,
      // ...
    }
  });

  // 添加节点
  builder.addNode("supervisor", createSupervisorAgent());
  builder.addNode("image_generation", createImageGenerationAgent());
  builder.addNode("text_overlay", createTextOverlayAgent());

  // 起始边
  builder.addEdge(START, "supervisor");

  return builder.compile();
}
```

**核心流程：**
```
START
  ↓
Supervisor Agent (决定下一步)
  ↓ Command({ goto: "image_generation" })
Image Generation Agent (执行任务)
  ↓ Command({ goto: "supervisor" })
Supervisor Agent (再次决定)
  ↓ Command({ goto: "text_overlay" }) 或 __end__
...
```

---

## 三、最终架构方案

### 1. Agent 结构对比

**用户原始想法：**
```
Supervisor Agent + 一个建模相关的子 Agent
```

**最终方案（多个专门的子 Agent）：**
```
Supervisor Agent (意图识别 + 动态路由)
  ↓
  ├─→ CreateAgent (创建对象，支持 interrupt)
  ├─→ DeleteAgent (删除对象，支持 interrupt)
  ├─→ ModifyAgent (修改对象，支持 interrupt)
  └─→ QueryAgent (查询对象)
```

**选择多个子 Agent 的原因：**
1. 符合 demo 的风格（多个专门的 agent）
2. 职责清晰，每个 agent 专注一个操作
3. 每个都可以独立支持 interrupt
4. 扩展性好（后面添加新功能容易）
5. 更好地借鉴 demo 的动态路由机制

### 2. 关键共识：所有子 Agent 都可能需要 interrupt ✅

**用户指出的重要问题：**
> "不只是 DeleteAgent 才有 interrupt，所有这些子 agent 都可能有 interrupt，比如在 xxx 附近新增对象。"

**完全正确！每个子 Agent 的 interrupt 场景：**

#### CreateAgent（创建对象）
**不需要 interrupt 的场景：**
- "画一个正方形，边长5，位置在 (10,0,10)" → 直接创建

**需要 interrupt 的场景：**
- "在坐标 (10,0,10) 附近创建正方形" → interrupt 调用 `getNearbyObjects` 找到合适位置
- "在上一个圆形旁边创建三角形" → interrupt 调用 `getLastCreated` 找到参考位置

#### DeleteAgent（删除对象）
**不需要 interrupt 的场景：**
- "删除 square_001" → 直接删除

**需要 interrupt 的场景：**
- "删除附近的圆形" → interrupt 调用 `getNearbyObjects`
- "删除上一个正方形" → interrupt 调用 `getLastCreated`

#### ModifyAgent（修改对象）
**不需要 interrupt 的场景：**
- "修改 square_001 的边长为10" → 直接修改

**需要 interrupt 的场景：**
- "修改上一个正方形的边长" → interrupt 调用 `getLastCreated`
- "修改坐标 (5,0,5) 附近的圆形" → interrupt 调用 `getNearbyObjects`

#### QueryAgent（查询对象）
**通常不需要 interrupt：**
- 直接查询数据库即可

---

## 四、完整工作流程示例

### 场景：在附近创建正方形

```typescript
// 1. 用户输入
const userInput = "在坐标 (10,0,10) 附近创建一个正方形，边长5";

// 2. 初始化 State
const initialState = {
  messages: [new HumanMessage(userInput)],
  intent: undefined,
  tempData: {},
};

// 3. 执行流程
workflow.invoke(initialState);

// ===== 执行过程 =====

// Step 1: Supervisor Agent
supervisorAgent(state) {
  // LLM 解析意图
  const intent = "create";  // 创建操作

  return new Command({
    goto: "create_agent",
    update: {
      intent: "create",
      messages: [...state.messages, "Supervisor: 路由到 create_agent"]
    }
  });
}

// Step 2: CreateAgent
createAgent(state) {
  // LLM 解析发现需要"附近"的位置信息
  const needsLocation = true;

  if (needsLocation) {
    // 触发 interrupt
    return interrupt({
      action: "getNearbyObjects",
      params: { x: 10, y: 0, z: 10, radius: 5 }
    });
  }

  // （执行暂停，等待前端 resume）
}

// Step 3: 前端检测 interrupt
frontend.onInterrupt((interruptData) => {
  // 执行前端工具
  const nearbyObjects = getNearbyObjects(10, 0, 10, 5);

  // Resume 执行
  client.runs.wait(threadId, "agent", {
    command: { resume: { nearbyObjects } }
  });
});

// Step 4: CreateAgent 恢复执行
createAgent(state) {
  // 现在 state.tempData.nearbyObjects 有值了
  const nearbyObjects = state.tempData.nearbyObjects;

  // 找到合适的位置（避开已有对象）
  const suitablePosition = findSuitablePosition(nearbyObjects);

  // 计算顶点
  const vertexList = calculateVertices(suitablePosition, 5);

  // 插入数据库
  await db.insert({ id: uuid(), type: "square", vertexList, ... });

  return new Command({
    goto: "supervisor",
    update: {
      tempData: { createdObjectId: "square_001" },
      messages: [...state.messages, "CreateAgent: 已创建正方形"]
    }
  });
}

// Step 5: Supervisor Agent 再次判断
supervisorAgent(state) {
  // 检查是否还有其他任务
  const hasMoreTasks = false;

  return new Command({
    goto: "__end__",
    update: {
      messages: [...state.messages, "Supervisor: 任务完成"]
    }
  });
}
```

---

## 五、数据库设计（最终版）

### 表 1：shapes
```sql
CREATE TABLE shapes (
  id TEXT PRIMARY KEY,              -- UUID
  type TEXT NOT NULL,               -- 'square' | 'circle' | 'triangle'
  vertexList TEXT NOT NULL,         -- JSON 存储顶点
  position_x REAL NOT NULL,         -- 中心 X
  position_y REAL NOT NULL,         -- 中心 Y（固定为0）
  position_z REAL NOT NULL,         -- 中心 Z
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_type ON shapes(type);
CREATE INDEX idx_created ON shapes(created_at DESC);
```

**vertexList 格式：**
- 正方形: `[[7.5,0,7.5], [12.5,0,7.5], [12.5,0,12.5], [7.5,0,12.5]]`
- 圆形: `{"center": [10,0,10], "radius": 5}`
- 三角形: `[[0,0,0], [5,0,0], [2.5,0,5]]`

### 表 2：shape_operations（支持 undo/redo）
```sql
CREATE TABLE shape_operations (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  session_id TEXT NOT NULL,
  shape_id TEXT,
  operation TEXT NOT NULL,          -- 'create' | 'update' | 'delete'
  before_state TEXT,                -- JSON
  after_state TEXT,                 -- JSON
  operated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_session ON shape_operations(session_id, operated_at DESC);
```

---

## 六、AgentState 设计

```typescript
interface AgentState {
  // 1. 对话历史（保留最近 20 条）
  messages: BaseMessage[];

  // 2. 会话信息
  sessionId: string;
  threadId: string;

  // 3. 当前意图和任务
  intent?: 'create' | 'delete' | 'modify' | 'query';
  next_agent?: string;
  current_task?: string;

  // 4. 临时数据（interrupt 恢复后的数据）
  tempData?: {
    // 前端工具返回的数据
    nearbyObjects?: Array<{id: string; type: string; distance: number}>;
    lastCreated?: {id: string; type: string};
    objectsInView?: Array<{id: string; type: string}>;

    // 当前操作的目标
    targetObjectId?: string;
    operationParams?: Record<string, any>;
  };

  // 5. 引用栈（优化阶段添加，用于"上一个正方形"）
  referencedObjects?: Array<{
    type: string;
    id: string;
    mentionedAt: number;
  }>;
}
```

---

## 七、前端工具定义

### 感知类工具（前端实现，通过 interrupt 调用）

```typescript
// 1. 获取坐标附近的对象
function getNearbyObjects(
  x: number,
  y: number,
  z: number,
  radius: number = 5
): Array<{
  id: string;
  type: string;
  position: [number, number, number];
  distance: number;
}> {
  const targetPos = new THREE.Vector3(x, y, z);
  const results = [];

  scene.children.forEach(obj => {
    if (obj.userData.id) {
      const distance = obj.position.distanceTo(targetPos);
      if (distance <= radius) {
        results.push({
          id: obj.userData.id,
          type: obj.userData.type,
          position: obj.position.toArray(),
          distance
        });
      }
    }
  });

  return results.sort((a, b) => a.distance - b.distance);
}

// 2. 获取最近创建的对象
function getLastCreated(
  type?: string,
  offset: number = 0
): {id: string; type: string} | null {
  // 从场景中找到最近创建的对象
  // MVP 阶段：根据数据库的 created_at 字段
  // 优化阶段：从引用栈中查找
}

// 3. 获取相机视野内的对象
function getObjectsInView(): Array<{
  id: string;
  type: string;
}> {
  // 使用 Three.js 的 Frustum 进行视锥体裁剪
}
```

---

## 八、任务主线（20 个任务，6 个 Phase）

### Phase 1: 项目基础搭建
1. ✅ 创建项目结构（backend/frontend）
2. ✅ 初始化后端项目（package.json、tsconfig、依赖）
3. ✅ 创建 SQLite 数据库和表结构
4. ✅ 配置环境变量和数据库连接

### Phase 2: LangGraph 架构
5. ✅ 定义 AgentState
6. ✅ 实现 Supervisor Agent（意图识别和路由）
7. ✅ 实现 CreateAgent（支持 interrupt）
8. ✅ 构建 LangGraph workflow

### Phase 3: MVP 测试（简单场景）
9. ✅ 实现 Express API（POST /api/chat）
10. ✅ 测试创建正方形（不需要 interrupt）

### Phase 4: 前端基础
11. ✅ 初始化前端项目（React + Vite）
12. ✅ 实现 Three.js 场景（3D 相机）
13. ✅ 实现对话框 UI
14. ✅ 实现前端渲染函数（renderShape）

### Phase 5: Interrupt 机制
15. ✅ 实现前端工具（getNearbyObjects）
16. ✅ 前端处理 interrupt 机制
17. ✅ 测试带 interrupt 的场景

### Phase 6: 完善功能
18. ✅ 实现 DeleteAgent（支持 interrupt）
19. ✅ 实现 ModifyAgent（支持 interrupt）
20. ✅ 添加圆形和三角形支持

---

## 九、开发方式约定

### 用户要求：
> "按你的循序渐进地写代码。但要有一条任务主线，就是假设我感觉哪里不对，做一些调整后，能回到继续开发的流程中。"

### 实施方式：
1. **任务主线**：使用 TodoWrite 工具跟踪所有任务
2. **循序渐进**：一个任务一个任务地完成
3. **可调整**：每个任务完成后，用户可以提出调整意见
4. **可恢复**：调整后，根据任务清单继续下一个任务
5. **文档记录**：每次讨论都创建独立的记录文件

---

## 十、关键技术决策总结

| 问题 | 决策 | 原因 |
|------|------|------|
| 数据库 | SQLite | 零配置，用户有 Navicat 可查看 |
| LLM API | 阿里云 Qwen | 从 .env 读取配置 |
| 项目结构 | 前后端分离 | backend/ 和 frontend/ |
| Agent 架构 | 多个子 Agent | 借鉴 demo，职责清晰 |
| Interrupt 支持 | 所有子 Agent | Create/Delete/Modify 都可能需要 |
| 路由方式 | Command + goto | 参考 demo/supervisor.ts |
| 开发方式 | 任务主线 + 可调整 | 保证开发流程连续性 |

---

## 十一、下一步行动

**现在开始 Phase 1 第一个任务：**
- 创建项目结构（backend/frontend 目录）

**用户确认后即可开始实施。** ✅
