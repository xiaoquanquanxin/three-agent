# Three-Agent 项目设计讨论记录

> 本文档记录项目设计过程中的关键决策和共识
> 最后更新：2026-01-09

---

## 一、已知需求（来自 README.md）

### 技术栈
- 后端：Node.js + TypeScript + LangGraph + Supervisor Agent
- 前端：Three.js + React
- 数据库：MySQL
- 后期：MCP 集成

### 核心功能
1. **界面布局**：左侧 Three.js 场景，右侧 Agent 对话框
2. **几何对象操作**：创建、删除、修改正方形、圆形、三角形
3. **两阶段决策模式**：
   - 感知阶段：通过工具获取场景信息（如 getNearbyObjects）
   - 决策阶段：基于获取的信息执行操作
4. **Supervisor Agent**：分析意图并路由到相应的子 Agent

---

## 二、核心架构设计（已确定）

### 整体数据流

```
用户输入
  ↓
后端 LangGraph (Supervisor Agent 意图识别)
  ↓
子 Agent (作为 Supervisor 的 tool)
  ↓
需要前端数据？
  → 是：后端 interrupt 并返回 {"status": "interrupted", "action": "getNearbyObjects", ...}
       前端执行工具 → 前端发新请求 POST /api/chat/continue
       后端从 checkpoint 恢复 → 继续执行
  → 否：直接执行业务逻辑
  ↓
后端更新数据库 + 返回 {"action": "delete", "targetId": "xxx"}
  ↓
前端根据 action 更新场景
```

**关键机制：**
- 使用 **LangGraph 的 interrupt + checkpoint** 实现"暂停-恢复"
- 不需要 WebSocket，每次都是前端主动发起 HTTP 请求
- 前后端数据通过数据库同步（数据库是唯一真相源）

---

## 三、已确定的设计方案

### 1. 数据流和通信机制 ✅

**用户观点：**
> 前后端通信用普通 HTTP，不需要轮询或 WebSocket。后端不是"直接调用"前端工具，而是返回指令（如 `{"action": "delete", "id": "xxx"}`），前端根据指令执行。数据库存储场景对象数据，前端启动时请求数据并渲染，前后端数据是同步的。

**设计方案：**
- **通信方式**：HTTP（RESTful API）
- **不需要 WebSocket**，因为：
  1. LangGraph 的 checkpoint 保存了会话状态
  2. 前端主动发起 continue 请求
  3. 后端通过 interrupt 机制暂停等待前端数据
- **数据同步**：
  1. 前端启动时：`GET /api/shapes` 获取所有场景对象
  2. 后续操作：数据库更新后，后端返回 action 指令，前端据此更新场景

**完整流程示例：**
```typescript
// 1. 用户输入
POST /api/chat
{
  "message": "删除坐标 (10,0,10) 附近的三角形",
  "sessionId": "session_123"
}

// 2. 后端响应（遇到 interrupt，需要前端提供数据）
{
  "status": "interrupted",
  "threadId": "thread_456",
  "action": "getNearbyObjects",
  "params": {"x": 10, "y": 0, "z": 10}
}

// 3. 前端执行工具后，继续请求
POST /api/chat/continue
{
  "threadId": "thread_456",
  "toolResult": [{"id": "tri_789", "type": "triangle", ...}]
}

// 4. 后端从 checkpoint 恢复，继续执行，完成操作
{
  "status": "completed",
  "action": "delete",
  "targetId": "tri_789",
  "message": "已删除该三角形"
}

// 5. 前端根据 action 删除场景对象
```

**结论：**
- [x] 使用 HTTP（不使用 WebSocket）
- [x] 利用 LangGraph 的 interrupt 和 checkpoint 机制
- [x] 前端主动轮询（通过 continue 请求）
- [x] 数据库是唯一数据源

---

### 2. 状态管理和数据一致性 ✅

**用户观点：**
> 数据库是唯一数据源。Three.js UUID 和数据库主键 ID 一致。对象数据由哪一端生成，ID 就由哪一端生成。

**设计方案：**
- **单一数据源**：数据库
- **对象创建流程**：
  1. 后端生成 UUID（使用 `uuid` 库）
  2. 插入数据库
  3. 返回给前端：`{"action": "create", "data": {...}}`
  4. 前端创建 Three.js 对象，设置 `object.userData.id = UUID`
- **ID 映射关系**：
  - 数据库主键 = Three.js 对象的 `userData.id`
  - 使用 UUID 格式（如 `550e8400-e29b-41d4-a716-446655440000`）
- **一致性保障**：
  - 数据库操作失败 → 后端返回错误，前端不执行场景更新
  - 前端渲染失败 → 前端捕获错误，调用 `/api/shapes/:id/rollback` 删除数据库记录

**结论：**
- [x] 数据库是唯一真相源
- [x] 后端生成 UUID 并插入数据库
- [x] Three.js UUID = 数据库主键 ID
- [x] 前端失败时需要回滚机制

---

### 3. 工具（Tool）的实现位置 ✅

**用户观点：**
> `getNearbyObjects` 在前端实现，目的是让前端过滤数据，避免 10000 个对象都喂给 LLM。后端知道前端有这些方法，让前端调用，前端再把结果返回给后端。

**设计方案：**

#### 感知类工具（Perception Tools）- 前端实现
- `getNearbyObjects(x, y, z, radius?)` - 获取坐标附近的对象
- `getLastCreated(type, offset?)` - 获取最近创建的对象（"上一个正方形"）
- `getObjectsInView()` - 获取相机视野内的对象
- **实现位置**：前端（Three.js 场景查询）
- **调用方式**：后端 interrupt → 前端执行 → continue 请求返回结果

#### 操作类工具（Action Tools）- 后端实现
- `createShape(type, params)` - 创建对象
- `deleteShape(id)` - 删除对象
- `modifyShape(id, params)` - 修改对象
- **实现位置**：后端（数据库操作）
- **执行方式**：后端直接执行，返回 action 指令给前端

#### 查询类工具（Query Tools）- 后端实现
- `listShapes(type?)` - 列举对象
- `getShapeById(id)` - 查询对象详情
- **实现位置**：后端（数据库查询）
- **执行方式**：后端直接查询数据库

**结论：**
- [x] 感知类工具由前端实现（过滤场景数据）
- [x] 操作类工具由后端实现（数据库 CRUD）
- [x] 通过 interrupt 机制调用前端工具
- [x] 不需要 RPC 协议（使用 HTTP + checkpoint）

---

### 4. LangGraph 架构设计 ✅

**用户观点：**
> LLM 能够判断用户意图。Supervisor Agent 负责整个流程状态，子 Agent 负责具体业务数据状态。子 Agent 是 Supervisor Agent 的 tool。参考 demo/supervisor.ts。

**设计方案：**

#### Supervisor Agent
- **职责**：意图识别和任务路由
- **输入**：用户消息 + 会话历史
- **输出**：路由到对应的子 Agent
- **实现**：通过 LLM 判断用户意图（"创建"、"删除"、"修改"、"查询"）

#### 子 Agent 划分（按操作类型）
1. **CreateAgent** - 处理创建对象请求
   - 解析参数（边长、半径、位置等）
   - 调用后端工具 `createShape`
   - 返回创建结果

2. **DeleteAgent** - 处理删除对象请求
   - 如果用户提供明确 ID → 直接删除
   - 如果用户提供位置/描述 → 调用前端工具 `getNearbyObjects` → 确认后删除

3. **ModifyAgent** - 处理修改对象请求
   - 如果用户说"上一个正方形" → 调用前端工具 `getLastCreated` → 获取 ID
   - 解析修改参数
   - 调用后端工具 `modifyShape`

4. **QueryAgent** - 处理查询请求
   - 调用后端工具 `listShapes`
   - 格式化输出

#### 状态传递机制
```typescript
// LangGraph State 定义
interface AgentState {
  // 基础信息
  sessionId: string;
  threadId: string;
  messages: Message[];

  // Supervisor 管理的全局状态
  currentIntent: 'create' | 'delete' | 'modify' | 'query';
  currentAgent: string;

  // 子 Agent 的业务数据
  targetObjectId?: string;
  operationParams?: Record<string, any>;

  // 两阶段决策
  perceptionResult?: any;  // 感知阶段的结果
  actionResult?: any;      // 决策阶段的结果

  // 会话引用栈（用于"上一个正方形"）
  referencedObjects: Array<{
    type: string;
    id: string;
    mentionedAt: number;
  }>;
}
```

**结论：**
- [x] Supervisor Agent 做意图识别
- [x] 子 Agent 按操作类型划分（Create/Delete/Modify/Query）
- [x] 子 Agent 作为 Supervisor 的 tool
- [x] 使用 AgentState 传递状态

---

### 5. 对象引用的歧义处理 ✅

**用户问题：**
> "上一个正方形"应该怎么定义？

**Claude 建议的方案：**

#### 方案 A：基于创建时间（简单）
- "上一个正方形" = 数据库中 `created_at` 最新的正方形
- **优点**：实现简单，数据库查询即可
- **缺点**：不符合对话语境

#### 方案 B：会话引用栈（推荐）
```typescript
interface SessionState {
  referencedObjects: Array<{
    type: 'square' | 'circle' | 'triangle';
    id: string;
    mentionedAt: number; // 第几轮对话
  }>;
}

// 规则：
// 1. 每次创建对象时，推入栈顶
// 2. 每次提到对象时，推入栈顶（或更新 mentionedAt）
// 3. "上一个X" = 栈中最近的 type=X 的对象
// 4. 栈保留最近 20 个引用（防止无限增长）
```

#### 方案 C：LLM 推断（最智能）
- 让 LLM 根据对话上下文自己判断"上一个"指的是哪个
- **优点**：最符合自然语言
- **缺点**：可能不稳定

**建议实施路径：**
1. MVP 阶段：使用方案 A（基于创建时间）
2. 优化阶段：升级到方案 B（引用栈）
3. 长期优化：探索方案 C（LLM 推断）

#### 其他歧义处理
- **"坐标附近"**：由前端判断，返回距离最近的对象（或前 N 个）
- **找到多个对象**：LLM 处理（让用户选择，或自动选最近的）
- **输入错误**：Tool schema 校验（如边长不能为负数）

**结论：**
- [x] MVP 使用基于创建时间的方案
- [x] 后续优化为会话引用栈
- [x] 坐标搜索由前端实现（简单距离计算）
- [x] Tool schema 做参数校验

---

### 6. 错误处理和回退机制 ⚠️

**待讨论问题：**
- [ ] `getNearbyObjects` 返回空时，是否扩大范围重试？
- [ ] 找到多个对象时，是让用户选择还是自动选最近的？
- [ ] 操作失败（如数据库错误）时的通知机制？

**初步方案：**
- 返回空 → 直接告诉用户"没找到对象"
- 多个对象 → LLM 询问用户选择（或提供默认选项"最近的"）
- 操作失败 → 后端返回 `{"status": "error", "message": "..."}`

**结论：**
（待讨论后确定）

---

### 7. 数据库表结构设计 ✅

**用户需求：**
> 不确定如何设计，需要支持 redo/undo。

**Claude 建议的方案：单表 + JSON + 操作历史表**

#### 主表：shapes
```sql
CREATE TABLE shapes (
  id VARCHAR(36) PRIMARY KEY,  -- UUID，由后端生成
  type ENUM('square', 'circle', 'triangle') NOT NULL,

  -- 几何数据（JSON 存储，支持不同形状）
  geometry JSON NOT NULL,
  /* 示例：
    square: {"sideLength": 5, "vertices": [[x1,y1,z1], [x2,y2,z2], [x3,y3,z3], [x4,y4,z4]]}
    circle: {"radius": 10, "center": [x, y, z]}
    triangle: {"vertices": [[x1,y1,z1], [x2,y2,z2], [x3,y3,z3]]}
  */

  -- 位置（用于快速过滤和查询优化）
  position_x FLOAT NOT NULL,
  position_y FLOAT NOT NULL,
  position_z FLOAT NOT NULL,

  -- 元数据
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  INDEX idx_type (type),
  INDEX idx_created (created_at DESC),
  INDEX idx_position (position_x, position_y, position_z)
);
```

#### 操作历史表：shape_operations
```sql
CREATE TABLE shape_operations (
  id INT AUTO_INCREMENT PRIMARY KEY,
  session_id VARCHAR(36) NOT NULL,  -- 会话 ID
  shape_id VARCHAR(36),              -- 操作的对象 ID（可能为 NULL，如创建失败）
  operation ENUM('create', 'update', 'delete') NOT NULL,

  -- 操作前的状态快照（用于 undo）
  before_state JSON,
  -- 操作后的状态快照（用于 redo）
  after_state JSON,

  -- 元数据
  operated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_session (session_id, operated_at DESC)
);
```

#### Undo/Redo 实现逻辑
```typescript
// Undo 流程：
// 1. 查询该 session 最近一条 operation
// 2. 读取 before_state
// 3. 根据 operation 类型：
//    - create → 删除对象（DELETE FROM shapes WHERE id = shape_id）
//    - update → 恢复到 before_state（UPDATE shapes SET ... WHERE id = shape_id）
//    - delete → 重新创建（INSERT INTO shapes ... VALUES from before_state）
// 4. 插入新的 operation 记录（标记为 undo 操作）
// 5. 返回给前端对应的 action 指令

// Redo 流程：类似，读取 after_state
```

**设计理由：**
- 使用 JSON 存储几何数据 → 灵活扩展新形状类型
- 单独的 operations 表 → 支持完整的 undo/redo
- position_x/y/z 字段 → 虽然前端做空间查询，但后端也可以做简单过滤

**结论：**
- [x] 使用单表 + JSON 存储几何数据
- [x] 单独的 operations 表支持 undo/redo
- [x] 不使用 MySQL 空间索引（场景规模不大）
- [x] 后端生成 UUID 作为主键

---

### 8. 关键接口协议定义 ✅

#### API 1: 用户输入（初始对话）
```typescript
POST /api/chat
Request:
{
  "message": string,        // 用户输入
  "sessionId": string       // 会话 ID（前端生成并保持）
}

Response (直接完成):
{
  "status": "completed",
  "action": "create" | "delete" | "modify" | "none",
  "data"?: {
    "id": string,
    "type": string,
    "geometry": object,
    "position": [number, number, number]
  },
  "targetId"?: string,      // 用于 delete/modify
  "message": string         // 返回给用户的消息
}

Response (需要前端工具):
{
  "status": "interrupted",
  "threadId": string,       // 用于 continue 请求
  "action": "getNearbyObjects" | "getLastCreated" | "getObjectsInView",
  "params": Record<string, any>
}
```

#### API 2: 继续对话（提供工具结果）
```typescript
POST /api/chat/continue
Request:
{
  "threadId": string,       // 从上次 interrupted 响应中获取
  "toolResult": any         // 前端工具执行的结果
}

Response: 同 API 1 的 Response
```

#### API 3: 获取场景对象（初始化）
```typescript
GET /api/shapes?sessionId={sessionId}
Response:
{
  "shapes": Array<{
    "id": string,
    "type": "square" | "circle" | "triangle",
    "geometry": object,
    "position": [number, number, number],
    "createdAt": string
  }>
}
```

#### API 4: Undo/Redo
```typescript
POST /api/operations/undo
Request:
{
  "sessionId": string
}

Response:
{
  "action": "create" | "delete" | "modify",
  "data"?: object,
  "targetId"?: string,
  "message": string
}

POST /api/operations/redo
（同 undo）
```

#### 前端工具定义（前端实现，后端通过 interrupt 调用）
```typescript
// 前端需要实现的工具函数
interface FrontendTools {
  getNearbyObjects(x: number, y: number, z: number, radius?: number): Array<{
    id: string;
    type: string;
    position: [number, number, number];
    distance: number;
  }>;

  getLastCreated(type?: string, offset?: number): {
    id: string;
    type: string;
  } | null;

  getObjectsInView(): Array<{
    id: string;
    type: string;
  }>;
}
```

**结论：**
- [x] 使用 RESTful HTTP API
- [x] 通过 interrupt/continue 机制调用前端工具
- [x] 单用户场景，sessionId 用于区分不同会话
- [x] 不需要 WebSocket

---

## 四、待讨论的问题

### 1. LangGraph 实现细节
- [ ] demo/supervisor.ts 的具体实现方式
- [ ] 如何定义 Tool schema
- [ ] 如何处理 interrupt 和 checkpoint

### 2. 前端 Three.js 实现
- [ ] 如何根据后端返回的 geometry 渲染对象
- [ ] 如何实现空间搜索（getNearbyObjects）
- [ ] 如何处理对象更新（morphing vs 重新创建）

### 3. 错误处理
- [ ] 网络错误时的重试机制
- [ ] 数据不一致时的修复策略
- [ ] 用户取消操作的处理

---

## 五、讨论进度

- [x] 2026-01-09：初始设计问题梳理
- [x] 2026-01-09：数据流和通信机制确定（HTTP + interrupt）
- [x] 2026-01-09：状态管理方案确定（数据库单一数据源）
- [x] 2026-01-09：工具实现位置确定（前端感知 + 后端操作）
- [x] 2026-01-09：LangGraph 架构设计（Supervisor + 子 Agent）
- [x] 2026-01-09：接口协议定义（RESTful API）
- [x] 2026-01-09：数据库设计（单表 + JSON + 历史表）
- [x] 2026-01-09：对象引用歧义处理方案（引用栈）
- [ ] LangGraph 具体实现
- [ ] 前端 Three.js 实现
- [ ] 错误处理机制

---

## 六、关键技术决策总结

| 问题 | 决策 | 理由 |
|------|------|------|
| 通信方式 | HTTP (不用 WebSocket) | LangGraph checkpoint + interrupt 机制足够 |
| 数据源 | 数据库单一数据源 | 前端只是渲染层，数据以数据库为准 |
| ID 生成 | 后端生成 UUID | 后端控制数据创建流程 |
| 感知工具 | 前端实现 | 避免大量数据传输，利用 Three.js 场景图 |
| 操作工具 | 后端实现 | 数据库操作由后端控制 |
| Agent 架构 | Supervisor + 子 Agent (按操作类型) | 清晰的职责划分 |
| 对象引用 | 会话引用栈（MVP 用创建时间） | 平衡实现复杂度和用户体验 |
| 数据库设计 | 单表 + JSON + 历史表 | 灵活性 + Undo/Redo 支持 |

---

## 七、下一步行动

1. [ ] 查看 demo/supervisor.ts，理解 LangGraph 实现方式
2. [ ] 实现数据库表结构
3. [ ] 实现后端 API 骨架
4. [ ] 实现前端基础场景（空场景 + 对话框）
5. [ ] 实现第一个完整流程（创建正方形）
6. [ ] 逐步添加其他功能
